import{S as a,b as r}from"./route-block-DpDnerku.js";import{_ as p,n as l}from"./VCol-4_oU8eBl.js";import{V as c,c as d}from"./VCard-nxBSYy8k.js";import{a as o,b as n}from"./VList-CAwl_Y47.js";import{x as m,q as f,f as t,v as i,y as e}from"./index-C-wSpYew.js";const g="/SitePortfolio/assets/StuctureProjet-BwtscgdJ.png",v="/SitePortfolio/assets/logsAncienneApplication-Bl2D30-W.png",b="/SitePortfolio/assets/PrincipesSOLID-DO88NU2K.png",h="/SitePortfolio/assets/instructionPr%C3%A9processeur-CVwo4wsF.png",q={class:"pa-4 pa-md-8"},u={__name:"competences",setup(x){return(y,s)=>(f(),m("div",q,[t(d,null,{default:i(()=>[t(c,null,{default:i(()=>[t(l,{cols:"12"},{default:i(()=>s[0]||(s[0]=[e("h1",{class:"text-h3 mb-4"},"Mes compétences",-1),e("p",{class:"text-body-1 opacity-80"}," Retrouvez ici un aperçu synthétique de mes compétences techniques et transversales. ",-1)])),_:1,__:[0]})]),_:1}),t(a,{id:"sommaire",title:"Sommaire",icon:"mdi-format-list-text"},{default:i(()=>[t(c,null,{default:i(()=>[t(l,{cols:"12",sm:"6",md:"4"},{default:i(()=>[t(o,{density:"compact",nav:""},{default:i(()=>[t(n,{to:{path:"/competences",hash:"#ac31-extend"},title:"Projet Extend (CF2P) — Analyse AC31","prepend-icon":"mdi-clipboard-text-outline"}),t(n,{to:{path:"/competences",hash:"#competence-realiser"},title:"Compétences Réaliser","prepend-icon":"mdi-account-star"}),t(n,{to:{path:"/competences",hash:"#competence-optimiser"},title:"Compétences Optimiser","prepend-icon":"mdi-account-star"}),t(n,{to:{path:"/competences",hash:"#competence-collaborer"},title:"Compétences Collaborer","prepend-icon":"mdi-account-star"}),t(n,{to:{path:"/competences",hash:"#tech"},title:"Langages / Frameworks","prepend-icon":"mdi-code-tags"}),t(n,{to:{path:"/competences",hash:"#langues"},title:"Langues","prepend-icon":"mdi-translate"})]),_:1})]),_:1})]),_:1})]),_:1}),t(a,{id:"competence-realiser",title:"Compétence Réaliser",icon:"mdi-briefcase-check-outline",subtitle:"Apprentissage critique analysé : AC31.01, AC31.02, AC31.03"},{default:i(()=>s[1]||(s[1]=[e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}},[e("p",null,"Dans le cadre de mon alternance de troisième année dans l’entreprise CF2P, nous avons réalisé la refonte complète d’une application existante nommée Extend, utilisée dans le domaine logistique pour la gestion des stocks, des chargements et des déplacements de lots. Cette application est un module supplémentaire à l’ERP qui est utilisé. Les lots correspondent à des panneaux à particules, suivis tout au long de leur cycle de stockage et de transport."),e("h1",null,"Analyse de l'existant"),e("p",null,"Le contexte initial présentait une difficulté majeure : nous ne disposions ni du code source, ni de documentation fonctionnelle de l’ancienne application. Nos seules sources d’information étaient les logs générés par l’ancienne version, ce qui a nécessité un important travail d’analyse pour comprendre les flux de données, les interactions entre systèmes et la logique métier. Comme vous pouvez le voir sur l'image ci-dessous Les informations que nous donnée les logs était quelle programme M3 était appele dans ce cas ci MHS850MI et les fonctions dans ce cas ci AddCoPick "),e("p"),e("h1",null,"Architecture de la nouvelle application"),e("p",null,"Pour l’architecture logiciel de la nouvelle application j’ai pu m’appuyer sur des principes vus en cours de programmation. Notemment l’architecture MVC qui permet de séparer les responsabilités de l’application, permettre également de facilité la maintenance de celle-ci. En effectuant des recherches l’architecture la plus utilisé pour une application développée en WPF est l’architecture MVVM. J’ai mis en place MVVM afin de séparer strictement l’UI, la logique de présentation et les services métier. Les vues XAML lient leur DataContext à des ViewModels qui exposent des propriétés observables (INotifyPropertyChanged) et des ICommand, générées via CommunityToolkit.Mvvm ([ObservableProperty], [RelayCommand]). Les interactions utilisateur (clavier/douchette) sont routées de façon découplée vers la page active au travers d’une abstraction commune, puis traduites en critères du ViewModel qui déclenche ses commandes (recherche, réinitialisation, impression, etc.). Les accès au système métier, notifications et impression sont fournis par des services injectés via interfaces, ce qui respecte l’inversion de dépendance et renforce la testabilité. La vue ne contient que du code d’interface (liaisons et déclenchement de commandes), la navigation restant indépendante de la logique. Ainsi comme vous pouvez le voir sur l’image suivante, j’ai pu découper mon projet avec différents dossiers qui permet de rendre le projet plus lisible pour une personne qui reprendra mon projet. "),e("figure",{class:"my-4",style:{"max-width":"400px"}},[e("img",{src:g,alt:"Structure de l'application MILF",style:{width:"100%",display:"block","border-radius":"4px"}}),e("figcaption",{class:"text-caption opacity-70 mt-2"},"Structure MVVM de l'application MILF")]),e("h1",null,"Faire évoluer une application existante"),e("p",null," Pour faire évoluer l’application existante Extend, que nous souhaitions remplacer, nous aurions pu analyser son code source afin d’identifier les fonctionnalités présentes. Cependant, ce logiciel n’avait pas été développé en interne par le service informatique, et nous n’avions donc pas accès à son code. Nous avons alors dû trouver d’autres solutions pour comprendre son fonctionnement. Pour cela, nous nous sommes appuyés sur l’analyse des logs de l’application, ce qui a demandé un travail conséquent afin de décrypter les flux de données avec l’ERP Infor M3, les interactions entre systèmes et la logique métier. Dans ces logs que nous avons récupéré nous savoir alors quels étaient les programmes et les fonctionns utilisé de l'ERP. Sur cette capture d'écran nous pouvons voir que le programme MHS850MI est appelé avec la fonction AddCoPick. Également nous pouvons voir les arguments passés à cette fonction. Cela a été trés utile pour savoir quels champs sont à réutiliser dans la nouvelle application. "),e("figure",{class:"my-4",style:{"max-width":"600px"}},[e("img",{src:v,alt:"Log de l'ancienne application",style:{width:"100%",display:"block","border-radius":"4px"}}),e("figcaption",{class:"text-caption opacity-70 mt-2"},"Log de l'ancienne application")]),e("p",null,"Comme l’illustre la capture d’écran suivante, j’ai conçu un fichier Excel répertoriant l’ensemble des programmes et fonctions utilisés dans l’application, en les classant selon les interfaces où ils apparaissent. Ce travail m’a ensuite permis de construire mon WebService, intégrant toutes les fonctionnalités nécessaires."),e("br"),e("p",null," Également lors de la programmation de la nouvelle application, j’ai pu mettre en pratique les savoirs sur Git que nous avons pu voir durant nos cours. J’ai pu alors créer des branches quand celle-ci étaient nécessaire, ce qui m’a permis de développer en parallèle des fonctionnalités sans que je ne modifie le code déjà terminé. "),e("p",null," Une fois mon projet programmé, j’ai refactorisé mon code pour améliorer son adhésion aux principes SOLID. J’ai d’abord appliqué le principe de responsabilité unique (Single Responsibility Principle) en évaluant le rôle de chaque classe et en m’assurant qu’aucune entité ne gère à la fois des logiques métier et des aspects techniques. Ensuite, j’ai mis en œuvre le principe ouvert/fermé (Open/Closed Principle) en réorganisant le code pour permettre l’extension des fonctionnalités sans modifier les classes existantes, grâce à l’héritage et aux interfaces. Concernant la substitution de Liskov (Liskov Substitution Principle), nous avons veillé à ce que les classes dérivées puissent remplacer leurs classes mères sans altérer le comportement global de l’application MILF, en repensant certaines hiérarchies de classes initialement trop rigides. J’ai également appliqué la ségrégation des interfaces (Interface Segregation Principle) pour que chaque composant n’implémente que les méthodes nécessaires à son rôle. Enfin, l’inversion de dépendance (Dependency Inversion Principle) a été centrale pour améliorer la modularité, en privilégiant les abstractions sur les implémentations concrètes, rendant ainsi le code plus flexible pour l’évolution de l’application MILF par quelqu’un qui n’a pas participé au projet. "),e("br"),e("p",null,"Voici par exemple un bout de code mettant en place quelque principes SOLID. J’ai conçu mon ViewModel pour qu’il dépende d’interfaces plutôt que d’implémentations concrètes (DIP). Cela me permet de remplacer facilement un service par une autre version sans modifier la structure globale du code (OCP, LSP). Enfin, les interfaces définies sont spécifiques et ciblées, ce qui évite d’imposer au ViewModel des méthodes inutiles (ISP). "),e("figure",{class:"my-4",style:{"max-width":"600px"}},[e("img",{src:b,alt:"Bout de code de ma classe montrant la mise en place de principes SOLID",style:{width:"100%",display:"block","border-radius":"4px"}}),e("figcaption",{class:"text-caption opacity-70 mt-2"},"Partie d'une classe mettant en place des principes SOLID ")]),e("h1",null,"Intégrer des solutions dans un environnement de production"),e("p",null," Pour développer la nouvelle application, j’ai commencé par mettre en place un environnement de test complet sur un serveur dédié. Cet environnement repose sur des machines virtuelles gérées par VMWare, ce qui permet une grande flexibilité. J’y ai installé une base de données PostgreSQL avec deux instances distinctes : une base de test, remplie avec des données réalistes pour simuler les différents rôles utilisateurs comme cariste ou administrateur, et une base de production. Et grâce au cours d'administration avancée BDD plutôt que de tout ressaisir manuellement, j’ai simplement effectué une sauvegarde de la base de test pour la restaurer en production, ce qui m’a fait gagner un temps précieux. Au niveau du code, j’ai utilisé des directives de préprocesseur pour adapter la compilation selon l’environnement cible. Que ce soit en mode DEBUG ou RELEASE, les paramètres de l’application, comme l’adresse de la base de données ou celle du webService de l’ERP, sont automatiquement ajustés. Cela évite toute confusion entre les configurations et garantit une transition sans erreur entre les environnements. "),e("figure",{class:"my-4",style:{"max-width":"600px"}},[e("img",{src:h,alt:"Insctruction de préprocesseur",style:{width:"100%",display:"block","border-radius":"4px"}}),e("figcaption",{class:"text-caption opacity-70 mt-2"},"Instruction de préprocesseur")]),e("p",null," Un autre aspect crucial a été la mise en place d’un système de logs détaillé. Nous avons séparé les logs de debug, qui tracent toutes les actions de l’application, des logs d’erreurs, qui enregistrent uniquement les anomalies. Ce système s’est révélé indispensable pour identifier l’origine des problèmes. Par exemple, lorsqu’un lot n’apparaissait pas sur une facture client, les logs ont montré que le cariste avait bien scanné le lot et que l’application avait transmis les bonnes informations à l’ERP. Grâce à cette traçabilité, nous avons pu déterminer que le problème venait en réalité d’un dysfonctionnement interne à l’ERP, et non de notre application. Cette approche m’a permis de valider que l’application fonctionne comme prévu et d’isoler rapidement les causes externes en cas d’incident. Le système de logs est devenu un outil clé pour assurer la fiabilité de l’application et faciliter le support technique. "),e("p",null,"Ce projet nous a permis de mettre en œuvre :"),e("p",{class:"bullet"},"• AC31.01 : choix et implémentation d’une architecture en couches adaptée (C#, WPF, SOLID), intégration des communications SOAP et gestion sécurisée des données."),e("p",{class:"bullet"},"• AC31.02 : refonte d’une application sans code source, analyse de logs pour comprendre le fonctionnement, utilisation de GitHub avec branches pour organiser le développement, refactoring continu et ajout de fonctionnalités."),e("p",{class:"bullet"},"• AC31.03 : intégration avec un ERP via SOAP, connexion à PostgreSQL pour l’authentification, documentation et préparation à un déploiement en environnement de production.")],-1)])),_:1,__:[1]}),t(a,{id:"competence-optimiser",title:"Compétence Optimiser",icon:"mdi-briefcase-check-outline",subtitle:"Apprentissage critique analysé : AC32.01, AC32.02, AC32.03"},{default:i(()=>s[2]||(s[2]=[e("h2",null,"Apprentissage critique AC32.01 : Anticiper les résultats de diverses métriques (temps d’exécution, occupation mémoire, montée en charge...)",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," Dans le cadre de mon projet, j’ai été amené à réfléchir à la performance du logiciel afin d’assurer un bon confort d’utilisation. Par exemple, lors du traitement et du stockage des données, j’ai anticipé le temps d’exécution et l’occupation mémoire en choisissant des structures adaptées, comme l’utilisation de struct plutôt que de class, celles-ci étant plus légères pour la transmission de données. Je me suis appuyé sur mes connaissances en algorithmique et en complexité pour évaluer l’impact de certaines opérations, en particulier dans les boucles et les manipulations répétées. Ainsi, j’ai effectué du refactoring afin d’inclure certains traitements directement dans une boucle. De plus, je me suis également penché sur les instructions LINQ que C# met à disposition : même si elles sont souvent plus compréhensibles d’un point de vue programmation, elles ne sont pas toujours les plus optimisées pour certaines opérations. Ce travail m’a permis de développer le savoir-faire d’optimisation de code, mais aussi de prendre en compte la montée en charge possible de l’application si le volume de données venait à augmenter. Cette capacité à anticiper m’a aidé à concevoir un logiciel robuste et capable de répondre efficacement à différents contextes d’utilisation. ",-1),e("br",null,null,-1),e("h2",null,"AC32.02 | Profiler, analyser et justifier le comportement d’un code existant",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," Au cours du développement, certaines parties de mon logiciel présentaient des lenteurs ou des comportements inattendus. J’ai donc dû analyser et profiler mon code afin de comprendre l’origine de ces problèmes. Pour cela, j’ai utilisé les outils de débogage intégrés ainsi que des impressions de logs pour identifier les portions de code trop coûteuses. J’ai ensuite comparé différentes approches de programmation, par exemple en remplaçant des boucles imbriquées par des méthodes plus efficaces, et j’ai justifié mes choix sur la base de critères de performance et de lisibilité. Ce travail m’a permis de mettre en œuvre le savoir-faire d’analyse de code existant, d’expliquer et de justifier mes décisions techniques, et de mieux comprendre l’impact des choix de programmation sur le comportement global de l’application. ",-1),e("br",null,null,-1),e("h2",null,"AC32.03 | Choisir et utiliser des bibliothèques et méthodes dédiées au domaine d’application",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," Pour répondre aux besoins de mon projet, j’ai intégré plusieurs bibliothèques et outils spécialisés, en particulier pour la gestion des données et l’interface utilisateur. J’ai choisi par exemple d’utiliser SQLite pour le stockage de certaines données, comme la liste des camions à charger lorsque la connexion avec l’ERP était suspendue, ainsi que WPF pour la partie graphique. Ces choix m’ont permis de bénéficier de solutions fiables et adaptées au domaine d’application. Ce choix ne s’est pas fait au hasard : j’ai dû rechercher, comparer et évaluer les bibliothèques disponibles, comme Windows Forms, qui s’avérait obsolète et pour lequel Microsoft préconise désormais l’utilisation de WPF. J’ai également dû adapter mon code métier pour exploiter efficacement ces bibliothèques. Le choix de la version du moteur .NET a aussi été déterminant, car Microsoft optimise régulièrement ce moteur, enrichit les fonctionnalités (comme LINQ) et améliore les structures de données. Cette étape m’a permis de développer mon savoir-faire dans l’intégration de solutions logicielles existantes et d’appliquer mes connaissances pour adapter des méthodes spécialisées au contexte précis de mon application. Ce travail illustre l’importance de savoir sélectionner les bons outils pour optimiser le développement et assurer la pérennité du projet. ",-1)])),_:1,__:[2]}),t(a,{id:"competence-collaborer",title:"Compétence Collaborer",icon:"mdi-briefcase-check-outline",subtitle:"Apprentissage critique analysé : AC36.01 AC36.02, AC31.03, AC36.04"},{default:i(()=>s[3]||(s[3]=[e("h2",null,"AC36.02 | Identifier les enjeux de l’économie de l’innovation numérique",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," Tout au long de mon projet, j’ai mis en place une veille technologique afin de rester informé sur les outils et les pratiques les plus adaptées. J’ai notamment suivi l’évolution des frameworks proposés par Microsoft, comme la comparaison entre Windows Forms et WPF, ou encore les nouvelles fonctionnalités offertes par les versions récentes de .NET. J’ai partagé cette veille avec mon équipe et mon tuteur afin de justifier mes choix techniques et d’orienter les décisions liées au développement. Ce travail m’a permis de développer le savoir-faire de recherche et de sélection d’informations pertinentes, mais aussi la capacité à organiser et transmettre efficacement ces informations pour qu’elles puissent servir à l’ensemble du projet. ",-1),e("br",null,null,-1),e("h2",null,"AC36.03 | Guider la conduite du changement informatique au sein d’une organisation",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," La mise en place de mon logiciel s’inscrivait dans une logique de remplacement d’un système déjà existant. J’ai donc dû réfléchir à la manière dont ce changement pouvait être accompagné au sein de l’organisation. Par exemple, j’ai veillé à ce que le déploiement de la nouvelle application soit simple grâce à ClickOnce, afin que les utilisateurs puissent bénéficier d’une mise à jour automatique sans interruption de leur travail. J’ai également pris en compte les habitudes des utilisateurs pour proposer une interface intuitive, ce qui a facilité l’adoption du nouvel outil. Cette expérience m’a permis de développer le savoir-faire d’accompagnement du changement en tenant compte des besoins métier, des contraintes techniques et de l’ergonomie logicielle. ",-1),e("br",null,null,-1),e("h2",null,"AC36.04 | Accompagner le management de projet informatique",-1),e("div",{class:"ac31-text text-body-1",style:{"text-align":"justify"}}," Dans le cadre de ce projet, j’ai participé activement à la gestion et au suivi de son avancement. J’ai organisé les tâches de développement, défini des priorités et proposé un découpage des fonctionnalités afin de rendre le travail plus structuré. J’ai également rendu compte régulièrement de l’avancée du projet à mon tuteur et adapté mon planning en fonction des retours. Cette expérience m’a permis de mobiliser des savoir-faire en gestion de projet, comme la planification, la communication avec les parties prenantes et la gestion des imprévus. Elle m’a aussi montré l’importance d’un suivi régulier et d’une bonne coordination pour mener un projet informatique à son terme. ",-1)])),_:1,__:[3]}),t(a,{id:"tech",title:"Langages de Programmation et Frameworks",icon:"mdi-code-tags"},{default:i(()=>[t(o,{density:"compact"},{default:i(()=>[t(n,{title:"C# / WPF / Entity Framework","prepend-icon":"mdi-code-tags"}),t(n,{title:"Java","prepend-icon":"mdi-language-java"}),t(n,{title:"HTML / CSS / JS / VueJS / NodeJS","prepend-icon":"mdi-language-javascript"}),t(n,{title:"SQL (PostgreSQL, MySQL, MongoDB)","prepend-icon":"mdi-database"})]),_:1})]),_:1}),t(a,{id:"soft",title:"Compétences personnelles",icon:"mdi-account-star"},{default:i(()=>[t(o,{density:"compact"},{default:i(()=>[t(n,{title:"Autonome","prepend-icon":"mdi-account-check-outline"}),t(n,{title:"Travail en équipe","prepend-icon":"mdi-account-group-outline"}),t(n,{title:"Flexibilité et adaptabilité","prepend-icon":"mdi-compare"}),t(n,{title:"Communication","prepend-icon":"mdi-forum-outline"})]),_:1})]),_:1}),t(a,{id:"langues",title:"Langues",icon:"mdi-translate"},{default:i(()=>[t(o,{density:"compact"},{default:i(()=>[t(n,{title:"Anglais — niveau convenable","prepend-icon":"mdi-flag-variant"})]),_:1})]),_:1})]),_:1})]))}};typeof r=="function"&&r(u);const S=p(u,[["__scopeId","data-v-22682a9f"]]);export{S as default};
